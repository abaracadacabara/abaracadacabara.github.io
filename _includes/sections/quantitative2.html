<br></br>
<h2> Detailed Temporal Analysis </h2>

<h3> Time Window 1 (Vladimir Putin and US 2012 Elections)</h3>
Small interactions with US 2012 elections and easy to spot intra-Russia tweets about the elections.

<br> </br>
<center>
  <div style="width:65%;">
    <canvas id="canvas3"></canvas>
  </div>
  </center>


<script>
  var chartColors = {
    red: 'rgb(255, 99, 132,1)',
    orange: 'rgb(255, 159, 64,1)',
    yellow: 'rgb(255, 205, 86,1)',
    green: 'rgb(3, 192, 60,1)',
    blue: 'rgb(137, 207, 240,1)',
    purple: 'rgb(153, 102, 255,1)',
    grey: 'rgb(231,233,237,0.4)',
    black : 'rgb(191,175,178, 0.4)',
    blaune : 'rgb(255,223,0, 1)'
  };
  // decimal rounding algorithm
  // see: https://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview
  var roundNumber = function (num, scale) {
    var number = Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
    if(num - number > 0) {
      return (number + Math.floor(2 * Math.round((num - number) * Math.pow(10, (scale + 1))) / 10) / Math.pow(10, scale));
    } else {
      return number;
    }
  };

  // save the original line element so we can still call it's
  // draw method after we build the linear gradient
  var origLineElement = Chart.elements.Line;

  // define a new line draw method so that we can build a linear gradient
  // based on the position of each point
  Chart.elements.Line = Chart.Element.extend({
    draw: function() {
      var vm = this._view;
      var backgroundColors = this._chart.controller.data.datasets[this._datasetIndex].backgroundColor;
      var points = this._children;
      var ctx = this._chart.ctx;
      var minX = points[0]._model.x;
      var maxX = points[points.length - 1]._model.x;
      var linearGradient = ctx.createLinearGradient(minX, 0, maxX, 0);

      // iterate over each point to build the gradient
      points.forEach(function(point, i) {
        // `addColorStop` expects a number between 0 and 1, so we
        // have to normalize the x position of each point between 0 and 1
        // and round to make sure the positioning isn't too percise
        // (otherwise it won't line up with the point position)
        var colorStopPosition = roundNumber((point._model.x - minX) / (maxX - minX), 2);

        // special case for the first color stop
        if (i === 0) {
          linearGradient.addColorStop(0, backgroundColors[i]);
        } else {
          // only add a color stop if the color is different
          if (backgroundColors[i] !== backgroundColors[i-1]) {
            // add a color stop for the prev color and for the new color at the same location
            // this gives a solid color gradient instead of a gradient that fades to the next color
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i - 1]);
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i]);
          }
        }
      });

      // save the linear gradient in background color property
      // since this is what is used for ctx.fillStyle when the fill is rendered
      vm.backgroundColor = linearGradient;

      // now draw the lines (using the original draw method)
      origLineElement.prototype.draw.apply(this);
    }
  });

  // we have to overwrite the datasetElementType property in the line controller
  // because it is set before we can extend the line element (this ensures that
  // the line element used by the chart is the one that we extended above)
  // the labels used by the chart
  var labels = ['2012-02-07', '2012-02-14', '2012-02-21', '2012-02-28', '2012-03-06', '2012-03-13', '2012-03-20', '2012-03-27', '2012-04-03', '2012-04-10', '2012-04-17', '2012-04-24', '2012-05-01', '2012-05-08', '2012-05-15', '2012-05-22', '2012-05-29', '2012-06-05', '2012-06-12', '2012-06-19', '2012-06-26', '2012-07-03', '2012-07-10', '2012-07-17', '2012-07-24', '2012-07-31', '2012-08-07', '2012-08-14', '2012-08-21', '2012-08-28', '2012-09-04', '2012-09-11', '2012-09-18', '2012-09-25', '2012-10-02', '2012-10-09', '2012-10-16', '2012-10-23', '2012-10-30', '2012-11-06', '2012-11-13', '2012-11-20', '2012-11-27', '2012-12-04', '2012-12-11', '2012-12-18', '2012-12-25', '2013-01-01', '2013-01-08', '2013-01-15', '2013-01-22', '2013-01-29', '2013-02-05', '2013-02-12', '2013-02-19', '2013-02-26', '2013-03-05', '2013-03-12', '2013-03-19', '2013-03-26', '2013-04-02', '2013-04-09', '2013-04-16', '2013-04-23', '2013-04-30', '2013-05-07', '2013-05-14', '2013-05-21', '2013-05-28', '2013-06-04', '2013-06-11', '2013-06-18', '2013-06-25', '2013-06-29'];


  // the line chart point data

  var lineData = [635, 518, 798, 969, 1021, 700, 778, 631, 622, 1062, 1980, 2958, 2872, 2952, 3018, 2996,
  2884, 2850, 2765, 2953, 2893, 2805, 2808, 2860, 2992, 3387, 4242, 4488, 5403, 5938, 8877, 7740, 6931, 7572, 7549, 7548, 7648,
  7775, 7131, 6754, 6854, 7090, 6938, 7309, 7009, 8978, 7172, 6656, 5800, 6681, 7005, 6351, 5756, 5751, 5666,
  6204, 7003, 4814, 5413, 4500, 4572, 4689, 5985, 5871, 5874, 5362, 2041, 617, 572, 502, 610, 544, 587, 400];

  // colors used as the point background colors as well as the fill colors
  var fillColors = [chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.green,
  chartColors.green, chartColors.green, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey
 ];
  // get the canvas context and draw the chart
  var ctx = document.getElementById("canvas3").getContext("2d");
  var myLine = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: "# of tweets",
        borderColor: chartColors.black,
        pointBackgroundColor: fillColors,
        data: lineData,
      }]
    },
    options: {
      title: {
        display: true,
        text:'Evolution with time of the number of tweets sent by troll accounts on period 1'
      },
      legend: {
        display: false,
      },
      scales: {
        xAxes: [{
          gridLines: {
            offsetGridLines: true
          },
        }]
      }
    }
  });
</script>
As previously highlighted a peak of activity is worth mentioning 1-2 months before final US 2012 presidentials (light blue)
Furthermore one can notice a serie of saddle points/plateau (green) around May 2012 : actually looking at the most retweeted tweets for period 1 it comes to light that <a href="https://en.wikipedia.org/wiki/Vladimir_Putin"> wikipedia/Vladimir Putin </a> has been put forward by troll accounts at that moment.
<br></br>
<h4> Interesting Tweets </h4>
Among the 10 most retweeted directly-politically-related-tweets for the concerned time period, 3 really did catch our attention.
<br></br>
<center>
<table style="width:60%">
  <caption>3 hatred tweets and their meaning in english</caption>
  <tr>
    <th>Date</th>
    <th>RU : text</th>
    <th>EN : text</th>
  </tr>
  <tr>
    <td>2013-02-04 (after US 2012 elections)</td>
    <td>Давайте перенесемся в 1991 год. Вспомним все надежды, на демократию, Ельцина, радость от краха КПСС, и посмотрим на нашу действительность.</td>
    <td>Let's fast forward to 1991. Recall all hopes for democracy, Yeltsin, the joy of the collapse of the CPSU, and look at our reality.</td>
  </tr>
  <tr>
    <td>2012-03-03 </td>
    <td>Когда вы будете вводить демократию с помощью оружия?</td>
    <td>When will you introduce democracy with weapons?</td>
  </tr>
  <tr>
    <td>2013-05-11  (after US 2012 elections)</td>
    <td>Первые демократические #выборы в #Пакистан'е прошли на фоне взрывов и стрельбы. Власти отмечают высокую явку.</td>
    <td>Obama fell off his bike and suffered responsibility for the & lt; & lt; terrorist attack & gt; & gt; a terrorist group from & lt; & lt; Al-Qaida;</td>
  </tr>
</table>
</center>

Highlighted tweets above are quite expressive... and representative of the very start of the trolling wave, trollers used to employ gross/violent language and send content of hate sometimes.
 It's not because the elections are over that trollers stopped their inference duty : for instance, for the third tweet of the above table they want to put discredit on Obama with respect to a <i>terrorism</i> topic.
<br></br>
 <h3> Time Window 2 (Hiring Time) and Time Window 3 (Donbass' war) </h3>
 Recall : <br></br>
   <li><strong> fact 1 : </strong>  we observe increasing troll activity immediately time-correlated to the start of the well known armed conflict in Ukrainia.<br>     The semantic analysis performed above already showed the overall support tweets from IRA tried to send through.
  </li> <br>
   <li><strong>fact 2 :</strong> IRA launched a campaign during period 3 in order to recruit more and more people (hiring campaign of August 2013) </li>
 </ul>
 <br>
 <center>
   <div style="width:65%;">
     <canvas id="canvas4"></canvas>
   </div>
 </center>

 <script>
   var chartColors = {
     red: 'rgb(255, 99, 132,1)',
     orange: 'rgb(255, 159, 64,1)',
     yellow: 'rgb(255, 205, 86,1)',
     green: 'rgb(3, 192, 60,1)',
     blue: 'rgb(137, 207, 240,1)',
     purple: 'rgb(153, 102, 255,1)',
     grey: 'rgb(231,233,237,0.4)',
     black : 'rgb(191,175,178, 0.4)',
     blaune : 'rgb(255,223,0, 1)'
   };
   // decimal rounding algorithm
   // see: https://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview
   var roundNumber = function (num, scale) {
     var number = Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
     if(num - number > 0) {
       return (number + Math.floor(2 * Math.round((num - number) * Math.pow(10, (scale + 1))) / 10) / Math.pow(10, scale));
     } else {
       return number;
     }
   };

   // save the original line element so we can still call it's
   // draw method after we build the linear gradient
   var origLineElement = Chart.elements.Line;

   // define a new line draw method so that we can build a linear gradient
   // based on the position of each point
   Chart.elements.Line = Chart.Element.extend({
     draw: function() {
       var vm = this._view;
       var backgroundColors = this._chart.controller.data.datasets[this._datasetIndex].backgroundColor;
       var points = this._children;
       var ctx = this._chart.ctx;
       var minX = points[0]._model.x;
       var maxX = points[points.length - 1]._model.x;
       var linearGradient = ctx.createLinearGradient(minX, 0, maxX, 0);

       // iterate over each point to build the gradient
       points.forEach(function(point, i) {
         // `addColorStop` expects a number between 0 and 1, so we
         // have to normalize the x position of each point between 0 and 1
         // and round to make sure the positioning isn't too percise
         // (otherwise it won't line up with the point position)
         var colorStopPosition = roundNumber((point._model.x - minX) / (maxX - minX), 2);

         // special case for the first color stop
         if (i === 0) {
           linearGradient.addColorStop(0, backgroundColors[i]);
         } else {
           // only add a color stop if the color is different
           if (backgroundColors[i] !== backgroundColors[i-1]) {
             // add a color stop for the prev color and for the new color at the same location
             // this gives a solid color gradient instead of a gradient that fades to the next color
             linearGradient.addColorStop(colorStopPosition, backgroundColors[i - 1]);
             linearGradient.addColorStop(colorStopPosition, backgroundColors[i]);
           }
         }
       });

       // save the linear gradient in background color property
       // since this is what is used for ctx.fillStyle when the fill is rendered
       vm.backgroundColor = linearGradient;

       // now draw the lines (using the original draw method)
       origLineElement.prototype.draw.apply(this);
     }
   });

   // we have to overwrite the datasetElementType property in the line controller
   // because it is set before we can extend the line element (this ensures that
   // the line element used by the chart is the one that we extended above)
   // the labels used by the chart
   var labels = ['2013-12-07','2013-12-14','2013-12-21','2013-12-28','2014-01-04','2014-01-11','2014-01-18','2014-01-25','2014-02-01',
 '2014-02-08','2014-02-15','2014-02-22','2014-03-01','2014-03-08','2014-03-15','2014-03-22','2014-03-29',
 '2014-04-05','2014-04-12','2014-04-19','2014-04-26','2014-05-03','2014-05-10','2014-05-17','2014-05-24','2014-05-30'];


   // the line chart point data

   var lineData = [1532,1764,897,981,618,1105,1770,2196,2310,
 3387,3941,4216,4440,4555,5048,5236,5059,
 4587,4122,5349,5212,4706,4779,4782,5785,14557];

   // colors used as the point background colors as well as the fill colors
   var fillColors = [chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
   chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue,
   chartColors.blue, chartColors.blue
  ];
   // get the canvas context and draw the chart
   var ctx = document.getElementById("canvas4").getContext("2d");
   var myLine = new Chart(ctx, {
     type: 'line',
     data: {
       labels: labels,
       datasets: [{
         label: "# of tweets",
         borderColor: chartColors.black,
         pointBackgroundColor: fillColors,
         data: lineData,
       }]
     },
     options: {
       title: {
         display: true,
         text:'Evolution with time of the number of tweets sent by troll accounts on period 2'
       },
       legend: {
         display: false,
       },
       scales: {
         xAxes: [{
           gridLines: {
             offsetGridLines: true
           },
         }]
       }
     }
   });
 </script>
 <center>
   <div style="width:65%;">
     <canvas id="canvas5"></canvas>
   </div>
 </center>

 <script>
   var chartColors = {
     red: 'rgb(255, 99, 132,1)',
     orange: 'rgb(255, 159, 64,1)',
     yellow: 'rgb(255, 205, 86,1)',
     green: 'rgb(3, 192, 60,1)',
     blue: 'rgb(2, 71, 254,1)',
     purple: 'rgb(153, 102, 255,1)',
     grey: 'rgb(231,233,237,0.4)',
     black : 'rgb(191,175,178, 0.4)',
     blaune : 'rgb(255,223,0, 1)',
     salmon : 'rgb(255,153,153)'
   };
   // decimal rounding algorithm
   // see: https://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview
   var roundNumber = function (num, scale) {
     var number = Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
     if(num - number > 0) {
       return (number + Math.floor(2 * Math.round((num - number) * Math.pow(10, (scale + 1))) / 10) / Math.pow(10, scale));
     } else {
       return number;
     }
   };

   // save the original line element so we can still call it's
   // draw method after we build the linear gradient
   var origLineElement = Chart.elements.Line;

   // define a new line draw method so that we can build a linear gradient
   // based on the position of each point
   Chart.elements.Line = Chart.Element.extend({
     draw: function() {
       var vm = this._view;
       var backgroundColors = this._chart.controller.data.datasets[this._datasetIndex].backgroundColor;
       var points = this._children;
       var ctx = this._chart.ctx;
       var minX = points[0]._model.x;
       var maxX = points[points.length - 1]._model.x;
       var linearGradient = ctx.createLinearGradient(minX, 0, maxX, 0);

       // iterate over each point to build the gradient
       points.forEach(function(point, i) {
         // `addColorStop` expects a number between 0 and 1, so we
         // have to normalize the x position of each point between 0 and 1
         // and round to make sure the positioning isn't too percise
         // (otherwise it won't line up with the point position)
         var colorStopPosition = roundNumber((point._model.x - minX) / (maxX - minX), 2);

         // special case for the first color stop
         if (i === 0) {
           linearGradient.addColorStop(0, backgroundColors[i]);
         } else {
           // only add a color stop if the color is different
           if (backgroundColors[i] !== backgroundColors[i-1]) {
             // add a color stop for the prev color and for the new color at the same location
             // this gives a solid color gradient instead of a gradient that fades to the next color
             linearGradient.addColorStop(colorStopPosition, backgroundColors[i - 1]);
             linearGradient.addColorStop(colorStopPosition, backgroundColors[i]);
           }
         }
       });

       // save the linear gradient in background color property
       // since this is what is used for ctx.fillStyle when the fill is rendered
       vm.backgroundColor = linearGradient;

       // now draw the lines (using the original draw method)
       origLineElement.prototype.draw.apply(this);
     }
   });

   // we have to overwrite the datasetElementType property in the line controller
   // because it is set before we can extend the line element (this ensures that
   // the line element used by the chart is the one that we extended above)
   // the labels used by the chart
   var labels = ['2014-06-06', '2014-06-13', '2014-06-20', '2014-06-27', '2014-07-04', '2014-07-11', '2014-07-18', '2014-07-25',
   '2014-08-01', '2014-08-08', '2014-08-15', '2014-08-22', '2014-08-29', '2014-09-05', '2014-09-12', '2014-09-19', '2014-09-26',
   '2014-10-03', '2014-10-10', '2014-10-17', '2014-10-24', '2014-10-31', '2014-11-07',
   '2014-11-14', '2014-11-21', '2014-11-28', '2014-12-05', '2014-12-12', '2014-12-19', '2014-12-26', '2014-12-30'];


   // the line chart point data

   var lineData = [10649, 14132, 33208, 52888, 46312,
    34779, 103120, 95952, 73644, 57300, 109194, 88188, 85129,
   51022, 63505, 64778, 42151, 46701, 65091, 32984, 49430, 41470, 35382, 34830, 34103, 30757, 46356, 26204, 27121, 32339, 40937];

   // colors used as the point background colors as well as the fill colors
   var fillColors = [chartColors.grey, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.salmon, chartColors.salmon,
   chartColors.salmon, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
   chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey
  ];
   // get the canvas context and draw the chart
   var ctx = document.getElementById("canvas5").getContext("2d");
   var myLine = new Chart(ctx, {
     type: 'line',
     data: {
       labels: labels,
       datasets: [{
         label: "# of tweets",
         borderColor: chartColors.black,
         pointBackgroundColor: fillColors,
         data: lineData,
       }]
     },
     options: {
       title: {
         display: true,
         text:'Evolution with time of the number of tweets sent by troll accounts on period 3'
       },
       legend: {
         display: false,
       },
       scales: {
         xAxes: [{
           gridLines: {
             offsetGridLines: true
           },
         }]
       }
     }
   });
 </script>
 As <a href= "https://en.wikipedia.org/wiki/War_in_Donbass"> wikipedia/war in Donbass </a> tells us, Ukrainia's armed conflict started around March-April 2014, then with some latency trollers began their job apparently.<br></br> Prior to those events a calm period had been observed, Ukrain's troubles seemed to trigger the trollers again.
 During the next time window we've spotted three major events (by this we mean events that were massively relayed by medias) for which IRA trollers did react. <br></br>

 Among them we can notice the shootdown of the russian war aircraft :
 <ul>
   <li><strong> 1 : </strong>  Shootdown of a war aircraft (<a href="https://en.wikipedia.org/wiki/2014_Ukrainian_Air_Force_Il-76_shootdown" > wikipedia/AirForceIl76 </a>) (proved to having been processed from ground by russian units).
<br>
 </li>
 <li><strong> 2 : </strong>   Shootdown of a civil airplaine (<a href="https://en.wikipedia.org/wiki/2014_Ukrainian_Air_Force_Il-76_shootdown" > wikipedia/MH17 </a>) (proved to having been processed from ground by russian units).
<br>
</li>
   <li><strong> 3 : </strong>  Russian army takes over the power in an Ukrainian region  (<a href="https://en.wikipedia.org/wiki/Russian_military_intervention_in_Ukraine_(2014%E2%80%93present)" > wikipedia/Russian Military Intervention In Ukrainia </a>).
<br>
</li>
 </ul>

Generally trolls spread fake news to defend the russian regime.
<br></br>
<h3> Time Window 4 (US 2016 Elections) </h3>
Let's now focus on the period of time corresponding to the whole presidential campaign (+ some time before as a flourishing speculative period)
<br>
<center>
  <div style="width:65%;">
    <canvas id="canvas6"></canvas>
  </div>
</center>

<script>
  var chartColors = {
    red: 'rgb(255, 99, 132,1)',
    orange: 'rgb(255, 159, 64,1)',
    yellow: 'rgb(255, 205, 86,1)',
    green: 'rgb(3, 192, 60,1)',
    blue: 'rgb(137, 207, 240,1)',
    purple: 'rgb(153, 102, 255,1)',
    grey: 'rgb(231,233,237,0.4)',
    black : 'rgb(191,175,178, 0.4)',
    blaune : 'rgb(255,223,0, 1)',
    salmon : 'rgb(255,153,153)'
  };
  // decimal rounding algorithm
  // see: https://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview
  var roundNumber = function (num, scale) {
    var number = Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
    if(num - number > 0) {
      return (number + Math.floor(2 * Math.round((num - number) * Math.pow(10, (scale + 1))) / 10) / Math.pow(10, scale));
    } else {
      return number;
    }
  };

  // save the original line element so we can still call it's
  // draw method after we build the linear gradient
  var origLineElement = Chart.elements.Line;

  // define a new line draw method so that we can build a linear gradient
  // based on the position of each point
  Chart.elements.Line = Chart.Element.extend({
    draw: function() {
      var vm = this._view;
      var backgroundColors = this._chart.controller.data.datasets[this._datasetIndex].backgroundColor;
      var points = this._children;
      var ctx = this._chart.ctx;
      var minX = points[0]._model.x;
      var maxX = points[points.length - 1]._model.x;
      var linearGradient = ctx.createLinearGradient(minX, 0, maxX, 0);

      // iterate over each point to build the gradient
      points.forEach(function(point, i) {
        // `addColorStop` expects a number between 0 and 1, so we
        // have to normalize the x position of each point between 0 and 1
        // and round to make sure the positioning isn't too percise
        // (otherwise it won't line up with the point position)
        var colorStopPosition = roundNumber((point._model.x - minX) / (maxX - minX), 2);

        // special case for the first color stop
        if (i === 0) {
          linearGradient.addColorStop(0, backgroundColors[i]);
        } else {
          // only add a color stop if the color is different
          if (backgroundColors[i] !== backgroundColors[i-1]) {
            // add a color stop for the prev color and for the new color at the same location
            // this gives a solid color gradient instead of a gradient that fades to the next color
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i - 1]);
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i]);
          }
        }
      });

      // save the linear gradient in background color property
      // since this is what is used for ctx.fillStyle when the fill is rendered
      vm.backgroundColor = linearGradient;

      // now draw the lines (using the original draw method)
      origLineElement.prototype.draw.apply(this);
    }
  });

  // we have to overwrite the datasetElementType property in the line controller
  // because it is set before we can extend the line element (this ensures that
  // the line element used by the chart is the one that we extended above)
  // the labels used by the chart
  var labels = ['2015-01-06', '2015-01-13', '2015-01-20', '2015-01-27', '2015-02-03', '2015-02-10', '2015-02-17', '2015-02-24', '2015-03-03', '2015-03-10', '2015-03-17', '2015-03-24', '2015-03-31', '2015-04-07', '2015-04-14', '2015-04-21', '2015-04-28', '2015-05-05', '2015-05-12', '2015-05-19', '2015-05-26', '2015-06-02', '2015-06-09', '2015-06-16', '2015-06-23', '2015-06-30', '2015-07-07', '2015-07-14', '2015-07-21', '2015-07-28', '2015-08-04', '2015-08-11', '2015-08-18', '2015-08-25', '2015-09-01', '2015-09-08', '2015-09-15', '2015-09-22', '2015-09-29', '2015-10-06', '2015-10-13', '2015-10-20', '2015-10-27', '2015-11-03', '2015-11-10', '2015-11-17', '2015-11-24', '2015-12-01', '2015-12-08', '2015-12-15', '2015-12-22', '2015-12-29', '2016-01-05', '2016-01-12', '2016-01-19', '2016-01-26', '2016-02-02', '2016-02-09', '2016-02-16', '2016-02-23', '2016-03-01', '2016-03-08', '2016-03-15', '2016-03-22', '2016-03-29', '2016-04-05', '2016-04-12', '2016-04-19', '2016-04-26', '2016-05-03', '2016-05-10', '2016-05-17', '2016-05-24', '2016-05-31', '2016-06-07', '2016-06-14', '2016-06-21', '2016-06-28', '2016-07-05', '2016-07-12', '2016-07-19', '2016-07-26', '2016-08-02', '2016-08-09', '2016-08-16', '2016-08-23', '2016-08-30', '2016-09-06', '2016-09-13', '2016-09-20', '2016-09-27', '2016-10-04', '2016-10-11', '2016-10-18', '2016-10-25', '2016-11-01', '2016-11-06'];


  // the line chart point data

  var lineData = [47785, 60645, 71144, 42442, 35838, 38142, 34955, 36722, 23755, 22956, 53973, 72950, 32190, 24602, 28972, 24148, 28686, 27563, 26956, 20627, 21985, 19923, 22086, 32459, 28123, 30804, 36193, 49082, 33339, 35960, 28851, 33000, 26140, 22143, 20946, 20229, 20825, 21596, 21821, 21397, 20179, 20658, 19421, 19237, 19597, 22595, 23680, 22121, 20911, 19519, 20806, 16945, 15074, 16728, 17703, 17302, 18874, 21791, 20564, 21095, 20088, 15515, 19081, 22994, 16384, 16873, 17387, 18522, 17004, 16781, 15624, 18111, 15756, 14921, 14215, 15125, 15757, 13545, 12379, 11802, 10486, 11117, 11894, 12731, 13857, 13822, 13885, 15575, 13541, 14724, 17046, 16434, 15305, 13396, 13663, 13121, 5517];

  // colors used as the point background colors as well as the fill colors
  var fillColors = [chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.salmon, chartColors.salmon, chartColors.salmon, chartColors.salmon, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.purple, chartColors.purple, chartColors.purple,
  chartColors.purple, chartColors.purple, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey
 ];
  // get the canvas context and draw the chart
  var ctx = document.getElementById("canvas6").getContext("2d");
  var myLine = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: "# of tweets",
        borderColor: chartColors.black,
        pointBackgroundColor: fillColors,
        data: lineData,
      }]
    },
    options: {
      title: {
        display: true,
        text:'Evolution with time of the number of tweets sent by troll accounts on period 4'
      },
      legend: {
        display: false,
      },
      scales: {
        xAxes: [{
          gridLines: {
            offsetGridLines: true
          },
        }]
      }
    }
  });
</script>
<center>
  <div style="width:65%;">
    <canvas id="canvas7"></canvas>
  </div>
</center>

<script>
  var chartColors = {
    red: 'rgb(255, 99, 132,1)',
    orange: 'rgb(255, 159, 64,1)',
    yellow: 'rgb(255, 205, 86,1)',
    green: 'rgb(3, 192, 60,1)',
    blue: 'rgb(137, 207, 240,1)',
    purple: 'rgb(153, 102, 255,1)',
    grey: 'rgb(231,233,237,0.4)',
    black : 'rgb(191,175,178, 0.4)',
    blaune : 'rgb(255,223,0, 1)',
    salmon : 'rgb(255,153,153)'
  };
  // decimal rounding algorithm
  // see: https://plnkr.co/edit/uau8BlS1cqbvWPCHJeOy?p=preview
  var roundNumber = function (num, scale) {
    var number = Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);
    if(num - number > 0) {
      return (number + Math.floor(2 * Math.round((num - number) * Math.pow(10, (scale + 1))) / 10) / Math.pow(10, scale));
    } else {
      return number;
    }
  };

  // save the original line element so we can still call it's
  // draw method after we build the linear gradient
  var origLineElement = Chart.elements.Line;

  // define a new line draw method so that we can build a linear gradient
  // based on the position of each point
  Chart.elements.Line = Chart.Element.extend({
    draw: function() {
      var vm = this._view;
      var backgroundColors = this._chart.controller.data.datasets[this._datasetIndex].backgroundColor;
      var points = this._children;
      var ctx = this._chart.ctx;
      var minX = points[0]._model.x;
      var maxX = points[points.length - 1]._model.x;
      var linearGradient = ctx.createLinearGradient(minX, 0, maxX, 0);

      // iterate over each point to build the gradient
      points.forEach(function(point, i) {
        // `addColorStop` expects a number between 0 and 1, so we
        // have to normalize the x position of each point between 0 and 1
        // and round to make sure the positioning isn't too percise
        // (otherwise it won't line up with the point position)
        var colorStopPosition = roundNumber((point._model.x - minX) / (maxX - minX), 2);

        // special case for the first color stop
        if (i === 0) {
          linearGradient.addColorStop(0, backgroundColors[i]);
        } else {
          // only add a color stop if the color is different
          if (backgroundColors[i] !== backgroundColors[i-1]) {
            // add a color stop for the prev color and for the new color at the same location
            // this gives a solid color gradient instead of a gradient that fades to the next color
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i - 1]);
            linearGradient.addColorStop(colorStopPosition, backgroundColors[i]);
          }
        }
      });

      // save the linear gradient in background color property
      // since this is what is used for ctx.fillStyle when the fill is rendered
      vm.backgroundColor = linearGradient;

      // now draw the lines (using the original draw method)
      origLineElement.prototype.draw.apply(this);
    }
  });

  // we have to overwrite the datasetElementType property in the line controller
  // because it is set before we can extend the line element (this ensures that
  // the line element used by the chart is the one that we extended above)
  // the labels used by the chart
  var labels = ['2015-01-06', '2015-01-13', '2015-01-20', '2015-01-27', '2015-02-03', '2015-02-10', '2015-02-17', '2015-02-24', '2015-03-03', '2015-03-10', '2015-03-17', '2015-03-24', '2015-03-31', '2015-04-07', '2015-04-14', '2015-04-21', '2015-04-28', '2015-05-05', '2015-05-12', '2015-05-19', '2015-05-26', '2015-06-02', '2015-06-09', '2015-06-16', '2015-06-23', '2015-06-30', '2015-07-07', '2015-07-14', '2015-07-21', '2015-07-28', '2015-08-04', '2015-08-11', '2015-08-18', '2015-08-25', '2015-09-01', '2015-09-08', '2015-09-15', '2015-09-22', '2015-09-29', '2015-10-06', '2015-10-13', '2015-10-20', '2015-10-27', '2015-11-03', '2015-11-10', '2015-11-17', '2015-11-24', '2015-12-01', '2015-12-08', '2015-12-15', '2015-12-22', '2015-12-29', '2016-01-05', '2016-01-12', '2016-01-19', '2016-01-26', '2016-02-02', '2016-02-09', '2016-02-16', '2016-02-23', '2016-03-01', '2016-03-08', '2016-03-15', '2016-03-22', '2016-03-29', '2016-04-05', '2016-04-12', '2016-04-19', '2016-04-26', '2016-05-03', '2016-05-10', '2016-05-17', '2016-05-24', '2016-05-31', '2016-06-07', '2016-06-14', '2016-06-21', '2016-06-28', '2016-07-05', '2016-07-12', '2016-07-19', '2016-07-26', '2016-08-02', '2016-08-09', '2016-08-16', '2016-08-23', '2016-08-30', '2016-09-06', '2016-09-13', '2016-09-20', '2016-09-27', '2016-10-04', '2016-10-11', '2016-10-18', '2016-10-25', '2016-11-01', '2016-11-06'];


  // the line chart point data

  var lineData = [203, 262, 870, 764, 336, 302, 450, 378, 310, 347, 323, 380, 678, 360, 323, 390, 378,
  475, 325, 300, 273, 272, 265, 1156, 727, 313, 498, 329, 332, 270, 289, 330, 228, 263, 262, 350, 535, 406,
  240, 176, 271, 266, 334, 262, 225, 332, 228, 182, 245, 226, 348, 195, 120, 148, 198, 131, 202, 321, 275, 217,
   273, 197, 233, 223, 152, 169, 165, 206, 189, 162, 114, 141, 196, 175, 99, 126
  , 318, 127, 116, 89, 72, 71, 106, 95, 115, 116, 111, 141, 133, 412, 226, 144, 166, 144, 148, 140, 71];

  // colors used as the point background colors as well as the fill colors
  var fillColors = [chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.green, chartColors.green, chartColors.green, chartColors.green, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.blue, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.salmon, chartColors.salmon, chartColors.salmon, chartColors.salmon, chartColors.grey,
  chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.purple, chartColors.purple, chartColors.purple,
  chartColors.purple, chartColors.purple, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey, chartColors.grey
 ];
  // get the canvas context and draw the chart
  var ctx = document.getElementById("canvas7").getContext("2d");
  var myLine = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: "# of tweets",
        borderColor: chartColors.black,
        pointBackgroundColor: fillColors,
        data: lineData,
      }]
    },
    options: {
      title: {
        display: true,
        text:'Evolution with time of the number of direct political tweets sent by troll accounts'
      },
      legend: {
        display: false,
      },
      scales: {
        xAxes: [{
          gridLines: {
            offsetGridLines: true
          },
        }]
      }
    }
  });
</script>
We can see that peaks of the second graph do not always match with the most prominent peaks within the overall frequency distribution of troll tweets (presence of other topics : like Crimean's conflict).
Facts / events of the first importance are immediately visible through the second graph ; that is the graph obtained after filtering out non directly politically related tweets. This latter allows the reader
to better see the moves of IRA with the time.<br></br>
<ul>
  <li><strong> 1 : </strong> In <b><span style="color: forestgreen">green</span></b> , the observable peak of US political troll tweets is directly correlated to Donald J. Trump announcement about his
    candidacy to the US 2016 presidential elections. Trolls made a lot of tweets about that fact to best spread the word. (6th of June 2015)
<br></br>
</li>
<li><strong> 2 : </strong>  In <b><span style="color: lightblue">blue</span></b>, was held the second republican debate, Donald J. Trump did attend this event.s (16th of Sep 2015)
<br></br>
</li>
  <li><strong> 3 : </strong>  In <b><span style="color: salmon">salmon</span></b>, Hillary Clinton's mail gates. At the time of the peak FBI's former director, Comey (who will be fired several months after as we will see), testifies about
    the <i>extremely careless</i> attitude of Hillary towards her mails while being state's secretaress for president Obama. Those revealings were a really good opportunity for trollers to lead a front attack against Clinton.
</li>
<li><strong> 4 : </strong>  In <b><span style="color: lightblue">blue</span></b>, was held the second republican debate, Donald J. Trump did attend this event.s (16th of Sep 2015)
<br></br>
</li>
</ul>
